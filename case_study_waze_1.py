# -*- coding: utf-8 -*-
"""Case Study Waze 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DkxAzkDBGZ8A4HroeZwzIu6xNSsYtcZe

# # **Projet Waze**
# **Cours 3 - Aller au-delà des chiffres : Traduire les données en informations**

# Votre équipe est encore aux premières étapes de son projet de désabonnement des utilisateurs. Jusqu'à présent, vous avez complété une proposition de projet et utilisé Python pour inspecter et organiser les données des utilisateurs de Waze.
#
# Vous vérifiez votre boîte de réception et remarquez un nouveau message de Chidi Ga, l'analyste de données senior de votre équipe. Chidi est satisfait du travail déjà réalisé et sollicite votre aide pour l'analyse exploratoire des données (EDA) et la visualisation des données. Harriet Hadzic, la directrice de l'analyse des données chez Waze, souhaitera examiner un carnet Python qui montre votre exploration et visualisation des données.
#
# Un carnet a été structuré et préparé pour vous aider dans ce projet. Veuillez répondre aux questions suivantes et préparer un résumé exécutif.

# # **Projet de fin de cours 3 : Analyse exploratoire des données**
#
# Dans cette activité, vous examinerez les données fournies et les préparerez pour l'analyse.
# <br/>
#
# **L'objectif** de ce projet est de réaliser une analyse exploratoire des données (EDA) sur un jeu de données fourni.
#
# **Le but** est de poursuivre l'examen des données que vous avez commencé dans le cours précédent, en ajoutant des visualisations pertinentes qui aident à communiquer l'histoire que les données racontent.
# <br/>
#
#
# *Cette activité se compose de 4 parties :*
#
# **Partie 1 :** Imports, liens et chargement
#
# **Partie 2 :** Exploration des données
# *   Nettoyage des données
#
#
# **Partie 3 :** Création de visualisations
#
# **Partie 4 :** Évaluation et partage des résulta
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

"""# Lisez les données et stockez-les dans un objet dataframe appelé df.

# Dans [2]:

# Chargez le jeu de données dans un dataframe

"""

df = pd.read_csv('waze_dataset.csv')

"""# <img src="images/Analyze.png" width="100" height="100" align=left>
#
# ## **PACE : Analyser**
#
# Réfléchissez aux questions de votre document de stratégie PACE et à celles ci-dessous, le cas échéant, pour compléter votre code :
# 1. Les données ont-elles besoin d'être restructurées ou converties en formats utilisables ?
#
# 2. Y a-t-il des variables avec des donn

"""

df.head(10)

"""# Dans [4]:"""

df.size

"""# Générez des statistiques récapitulatives en utilisant la méthode `describe()`.

# Dans [5]:

"""

df.describe()

"""# Et des informations récapitulatives en utilisant la méthode `info()`.

# Dans [6]:

"""

df.info()

"""
# ## **PACE : Construire**
#
# Réfléchissez aux questions de votre document de stratégie PACE pour réfléchir à la phase Construire.

# Réfléchissez aux questions suivantes lorsque vous vous préparez à gérer les valeurs aberrantes :
#
# 1. Quelles sont les méthodes pour identifier les valeurs aberrantes ?
#   * Utilisez les fonctions numpy pour examiner la `mean()` et la `median()` des données et comprendre l'étendue des valeurs des données
#   * Utilisez un boxplot pour visualiser la distribution des données
#
# 2. Comment prenez-vous la décision de conserver ou d'exclure les valeurs aberrantes des modèles futurs ?
#
#   * Il existe trois options principales pour gérer les valeurs aberrantes : les conserver telles quelles, les supprimer ou les réassigner. Que vous conserviez les valeurs aberrantes telles quelles, les supprimiez ou réattribuiez des valeurs dépend de votre analyse de l'ensemble de données et des objectifs du modèle que vous prévoyez de construire. Pour vous aider à prendre cette décision, vous pouvez commencer par ces lignes directrices générales :
#
#     * Supprimez-les : Si vous êtes sûr que les valeurs aberrantes sont des erreurs, des fautes de frappe ou des erreurs et que l'ensemble de données sera utilisé pour la modélisation ou l'apprentissage automatique, vous êtes plus susceptible de décider de supprimer les valeurs aberrantes. Parmi les trois options, c'est celle que vous utiliserez le moins souvent.
#     * Réattribuez-les : Si l'ensemble de données est petit et/ou que les données seront utilisées pour la modélisation ou l'apprentissage automatique, vous êtes plus susceptible de choisir une méthode consistant à dériver de nouvelles valeurs pour remplacer les valeurs aberrantes.
#     * Laissez-les : Pour un ensemble de données que vous prévoyez d'analyser sans modélisation, ou pour un ensemble de données que vous préparez pour un modèle résistant aux valeurs aberrantes, il est plus probable que vous laissiez les valeurs aberrantes en place.

# ### **Tâche 3a. Visualisations**
#
# Sélectionnez les types de visualisation des données qui vous aideront à comprendre et à expliquer les données.
#
# Maintenant que vous savez quelles colonnes de données vous allez utiliser, il est temps de décider quelle visualisation des données a le plus de sens pour l'EDA du jeu de données Waze.
#
# **Question :** Quel type de visualisation des données sera le plus utile ?
#
# * Graphique en ligne
# * Diagramme en barres
# * Box plot
# * Histogramme
# * Carte thermique
# * Diagramme de dispersion
# * Carte géographique
#
# **Réponse :**
#
# *    Les box plots seront utiles pour déterminer les valeurs aberrantes et l'endroit où la majeure partie des points de données se situe en termes de `drives`, `sessions` et toutes les autres variables numériques continues
# *     Les histogrammes sont essentiels pour comprendre la distribution des variables
# *     Les diagrammes de dispersion seront utiles pour visualiser les relations entre les variables
# *     Les diagrammes en barres sont utiles pour communiquer les niveaux et quantités, en particulier pour les informations catégorielles

# Commencez par examiner la répartition et la distribution des variables importantes en utilisant des box plots et des histogrammes.

# #### **`sessions`**
#
# _Le nombre de fois qu'un utilisateur ouvre l'application pendant le mois_

# Dans [7]:

# Box plot
"""

plt.figure(figsize=(5,1))
sns.boxplot(x=df['sessions'], fliersize=1)
plt.title('sessions box plot');

"""# Dans [8]:

# Histogramme

"""

plt.figure(figsize=(5,3))
sns.histplot(x=df['sessions'])
median = df['sessions'].median()
plt.axvline(median, color='red', linestyle='--')
plt.text(75,1200, 'median=56.0', color='red')
plt.title('sessions box plot');

"""# La variable `sessions` a une distribution asymétrique à droite, avec la moitié des observations ayant 56 sessions ou moins. Cependant, comme l'indique le boxplot, certains utilisateurs ont plus de 700 sessions.

# #### **`drives`**
#
# _Un événement de conduite d'au moins 1 km pendant le mois_

# Dans[9]:

# Box plot

"""

plt.figure(figsize=(5,1))
sns.boxplot(x=df['drives'], fliersize=1)
plt.title('drives box plot');

"""# Lorsque vous effectuez l'EDA, vous constaterez que de nombreuses tâches sont répétées, comme le traçage des histogrammes des caractéristiques. N'oubliez pas que chaque fois que vous vous retrouvez à copier/coller du code, il est utile de vous demander si une fonction pourrait rendre votre travail plus efficace. Parfois, cela ne vaut pas le coup. D'autres fois, définir une fonction peut être très utile.
#
# Le bloc de code suivant définit une fonction qui aide à tracer des histogrammes avec un style/format particulier en utilisant cet ensemble de données. Vous n'êtes pas obligé de le faire, mais dans ce cas, c'est utile.

# Dans [10]:

# Fonction utilitaire pour tracer les histogrammes en fonction du
# format de l'histogramme `sessions`

"""

def histogrammer(column_str, median_text=True, **kwargs):    # **kwargs = any keyword arguments
                                                             # from the sns.histplot() function
    median=round(df[column_str].median(), 1)
    plt.figure(figsize=(5,3))
    ax = sns.histplot(x=df[column_str], **kwargs)            # Plot the histogram
    plt.axvline(median, color='red', linestyle='--')         # Plot the median line
    if median_text==True:                                    # Add median text unless set to False
        ax.text(0.25, 0.85, f'median={median}', color='red',
            ha='left', va='top', transform=ax.transAxes)
    else:
        print('Median:', median)
    plt.title(f'{column_str} histogram');

"""# Dans [11]:

# Histogramme

"""

histogrammer('drives')

"""# L'information `drives` suit une distribution similaire à celle de la variable `sessions`. Elle est asymétrique à droite, approximativement log-normale, avec une médiane de 48. Cependant, certains conducteurs ont eu plus de 400 trajets au cours du dernier mois.

# #### **`total_sessions`**
#
# _Une estimation du modèle du nombre total de sessions depuis l'inscription d'un utilisateur_

# Dansn [12]:

# Box plot

"""

plt.figure(figsize=(5,1))
sns.boxplot(x=df['total_sessions'], fliersize=1)
plt.title('total_sessions box plot');

"""# Dans [13]:

# Histogramme

"""

histogrammer('total_sessions')

"""# La distribution de `total_sessions` est asymétrique à droite. Le nombre médian total de sessions est de 159,6. C'est une information intéressante car, si le nombre médian de sessions au cours du dernier mois était de 56 et le nombre médian total de sessions était d'environ 160, il semble qu'une grande proportion des trajets totaux (estimés) d'un utilisateur ait eu lieu au cours du dernier mois. C'est quelque chose que vous pourrez examiner de plus près plus tard.

# #### **`n_days_after_onboarding`**
#
# _Le nombre de jours depuis l'inscription d'un utilisateur à l'application_

# Dans [14]:

# Box plot

"""

plt.figure(figsize=(5,1))
sns.boxplot(x=df['n_days_after_onboarding'], fliersize=1)
plt.title('n_days_after_onboarding box plot');

"""# Dans [15]:


# Histogramme
"""

histogrammer('n_days_after_onboarding', median_text=False)

"""# La durée totale d'utilisation des utilisateurs (c'est-à-dire, le nombre de jours depuis
# l'inscription) suit une distribution uniforme avec des valeurs allant de près de zéro à ~3 500 (~9,5 ans).

# #### **`driven_km_drives`**
#
# _Kilomètres totaux parcourus pendant le mois_

# Dans [16]:

# Box plot

"""

plt.figure(figsize=(5,1))
sns.boxplot(x=df['driven_km_drives'], fliersize=1)
plt.title('driven_km_drives box plot');

"""# Dans [17]:


# Histogramme
"""

histogrammer('driven_km_drives')

"""# Le nombre de trajets effectués le mois dernier par utilisateur suit une distribution asymétrique à droite, avec la moitié des utilisateurs conduisant moins de 3 495 kilomètres. Comme vous l'avez découvert dans l'analyse du cours précédent, les utilisateurs de cet ensemble de données conduisent _beaucoup_. La distance la plus longue parcourue durant le mois était plus de la moitié de la circonférence de la Terre.

# #### **`duration_minutes_drives`**
#
# _Durée totale de conduite en minutes pendant le mois_

# Dans [18]:

# Box plot

"""

plt.figure(figsize=(5,1))
sns.boxplot(x=df['duration_minutes_drives'], fliersize=1)
plt.title('duration_minutes_drives box plot');

"""# Dans [19]:


# Histogramme
"""

histogrammer('duration_minutes_drives')

"""# La variable `duration_minutes_drives` a une longue queue asymétrique à droite. La moitié des utilisateurs ont conduit moins de ~1 478 minutes (~25 heures), mais certains utilisateurs ont dépassé les 250 heures au cours du mois.

# #### **`activity_days`**
#
# _Nombre de jours où l'utilisateur ouvre l'application pendant le mois_

# Dans [20]:

# Box plot

"""

plt.figure(figsize=(5,1))
sns.boxplot(x=df['activity_days'], fliersize=1)
plt.title('activity_days box plot');

"""# Dans [21]:


# Histogramme
"""

histogrammer('activity_days', median_text=False, discrete=True)

"""# Au cours du dernier mois, les utilisateurs ont ouvert l'application en moyenne 16 fois. Le box plot révèle une distribution centrée. L'histogramme montre une distribution presque uniforme de ~500 personnes ouvrant l'application à chaque nombre de jours. Cependant, il y a ~250 personnes qui n'ont pas ouvert l'application du tout et ~250 personnes qui ont ouvert l'application chaque jour du mois.
#
# Cette distribution est remarquable car elle ne reflète pas la distribution de `sessions`, que l'on pourrait penser étroitement corrélée à `activity_days`.

# #### **`driving_days`**
#
# _Nombre de jours où l'utilisateur conduit (au moins 1 km) pendant le mois_

# Dans [22]:

# Box plot

"""

plt.figure(figsize=(5,1))
sns.boxplot(x=df['driving_days'], fliersize=1)
plt.title('driving_days box plot');

"""# Dans [23]:


# Histogramme
"""

histogrammer('driving_days', median_text=False, discrete=True)

"""# Le nombre de jours où les utilisateurs ont conduit chaque mois est presque uniforme, et il corrèle largement avec le nombre de jours où ils ont ouvert l'application ce mois-là, sauf que la distribution de `driving_days` s'étend à droite.
#
# Cependant, il y a presque deux fois plus d'utilisateurs (~1 000 contre ~550) qui n'ont pas conduit du tout pendant le mois. Cela peut sembler contre-intuitif lorsqu'on le considère avec les informations de `activity_days`. Cette variable avait ~500 utilisateurs ouvrant l'application à chacun des comptes de jours, mais il n'y avait que ~250 utilisateurs qui n'ont pas ouvert l'application du tout pendant le mois et ~250 utilisateurs qui ont ouvert l'application chaque jour. À signaler pour une enquête plus approfondie plus tard.
#
# #### **`device`**
#
# _Le type d'appareil avec lequel un utilisateur commence une session_
#
# Il s'agit d'une variable catégorielle, donc vous ne tracez pas un box plot pour celle-ci. Un bon graphique pour une variable catégorielle binaire est un graphique en secteurs.

# Dans [24]:

# Graphique en secteurs

"""

fig = plt.figure(figsize=(3,3))
data=df['device'].value_counts()
plt.pie(data,
        labels=[f'{data.index[0]}: {data.values[0]}',
                f'{data.index[1]}: {data.values[1]}'],
        autopct='%1.1f%%'
        )
plt.title('Users by device');

"""# Il y a presque deux fois plus d'utilisateurs iPhone que d'utilisateurs Android représentés dans ces données.

# #### **`label`**
#
# _Variable cible binaire (“retenu” vs “parti”) pour savoir si un utilisateur a quitté l'application à un moment donné au cours du mois_
#
# Il s'agit également d'une variable catégorielle, et ne devrait donc pas être tracée sous forme de box plot. Tracez plutôt un graphique en secteurs.

# Dans [25]:

# Graphique en secteurs

"""

fig = plt.figure(figsize=(3,3))
data=df['label'].value_counts()
plt.pie(data,
        labels=[f'{data.index[0]}: {data.values[0]}',
                f'{data.index[1]}: {data.values[1]}'],
        autopct='%1.1f%%'
        )
plt.title('Count of retained vs. churned');

"""# Moins de 18 % des utilisateurs ont quitté l'application.

# #### **`driving_days` vs. `activity_days`**
#
# Étant donné que les variables `driving_days` et `activity_days` représentent toutes deux le nombre de jours sur un mois et qu'elles sont également étroitement liées, vous pouvez les tracer ensemble dans un seul histogramme. Cela vous aidera à mieux comprendre comment elles sont liées sans avoir à faire défiler les histogrammes dans deux endroits différents pour les comparer.
#
# Tracez un histogramme où, pour chaque jour, il y a une barre représentant les comptes de `driving_days` et `activity_days`.

# Dans [26]:

# Histogramme

"""

plt.figure(figsize=(12,4))
label=['driving days', 'activity days']
plt.hist([df['driving_days'], df['activity_days']],
         bins=range(0,33),
         label=label)
plt.xlabel('days')
plt.ylabel('count')
plt.legend()
plt.title('driving_days vs. activity_days');

"""# Comme observé précédemment, cela peut sembler contre-intuitif. Après tout, pourquoi y a-t-il _moins_ de personnes qui n'ont pas utilisé l'application du tout pendant le mois et _plus_ de personnes qui n'ont pas conduit du tout pendant le mois ?
#
# D'autre part, cela pourrait simplement illustrer le fait que, bien que ces variables soient liées entre elles, elles ne sont pas identiques. Les gens ouvrent probablement l'application plus qu'ils ne l'utilisent pour conduire—peut-être pour vérifier les temps de conduite ou les informations de trajet, mettre à jour les paramètres, ou même juste par erreur.
#
# Néanmoins, il pourrait être utile de contacter l'équipe des données de Waze pour obtenir plus d'informations à ce sujet, surtout parce qu'il semble que le nombre de jours dans le mois ne soit pas le même entre les variables.
#
# Confirmez le nombre maximum de jours pour chaque variable—`driving_days` et `activity_days`.

# Dans [27]:

"""

print(df['driving_days'].max())
print(df['activity_days'].max())

"""# C'est vrai. Bien qu'il soit possible qu'aucun utilisateur n'ait conduit tous les 31 jours du mois, c'est très peu probable, étant donné qu'il y a 15 000 personnes représentées dans le jeu de données.
#
# Une autre façon de vérifier la validité de ces variables est de tracer un simple graphique de dispersion avec l'axe des x représentant une variable et l'axe des y représentant l'autre.

# Dans [28]:

"""

sns.scatterplot(data=df, x='driving_days', y='activity_days')
plt.title('driving_days vs. activity_days')
plt.plot([0,31], [0,31], color='red', linestyle='--');

"""# Remarque qu'il y a une limite théorique. Si vous utilisez l'application pour conduire, alors par définition cela doit également être comptabilisé comme un jour d'utilisation. En d'autres termes, vous ne pouvez pas avoir plus de jours de conduite que de jours d'activité. Aucun des échantillons dans ces données ne viole cette règle, ce qui est bon.

# #### **Rétention par appareil**
#
# Tracez un histogramme qui comporte quatre barres—une pour chaque combinaison appareil-étiquette—pour montrer combien d'utilisateurs iPhone ont été retenus ou ont quitté, et combien d'utilisateurs Android ont été retenus ou ont quitté.

# Dans [29]:

"""

plt.figure(figsize=(5,4))
sns.histplot(data=df,
             x='device',
             hue='label',
             multiple='dodge',
             shrink=0.9
             )
plt.title('Retention by device histogram');

"""# La proportion des utilisateurs ayant quitté l'application par rapport à ceux restant est cohérente entre les types de dispositifs.

# #### **Rétention selon les kilomètres parcourus par jour de conduite**
#
# Dans le cours précédent, vous avez découvert que la distance médiane parcourue par jour de conduite le mois dernier pour les utilisateurs ayant quitté l'application était de 697,54 km, contre 289,55 km pour ceux qui n'ont pas quitté l'application. Examinez cela de plus près.
#
# 1. Créez une nouvelle colonne dans `df` appelée `km_per_driving_day`, qui représente la distance moyenne parcourue par jour de conduite pour chaque utilisateur.
#
# 2. Appelez la méthode `describe()` sur la nouvelle colonne.

# Dans [30]:

# 1. Créez la colonne `km_per_driving_day`

"""

df.loc[df['km_per_driving_day']==np.inf, 'km_per_driving_day'] = 0

"""# 2. Confirmez que ça a marché"""

df['km_per_driving_day'].describe()

"""# La valeur maximale est de 15 420 kilomètres _par jour de conduite_. Cela est physiquement impossible. Conduire à 100 km/h pendant 12 heures représente 1 200 km. Il est peu probable que beaucoup de gens aient parcouru plus que cela chaque jour où ils ont conduit, donc, pour l'instant, ignorez les lignes où la distance dans cette colonne est supérieure à 1 200 km.
#
# Tracez un histogramme de la nouvelle colonne `km_per_driving_day`, en ignorant les utilisateurs avec des valeurs supérieures à 1 200 km. Chaque barre doit avoir la même longueur et comporter deux couleurs : une couleur représentant le pourcentage des utilisateurs dans cette barre qui ont quitté l'application et l'autre représentant le pourcentage des utilisateurs restants. Cela peut être fait en définissant le paramètre `multiple` de la fonction [`histplot()`](https://seaborn.pydata.org/generated/seaborn.histplot.html) de seaborn sur `fill`.

# Dans [32]:


# Histogram

"""

plt.figure(figsize=(12,5))
sns.histplot(data=df,
             x='km_per_driving_day',
             bins=range(0,1201,20),
             hue='label',
             multiple='fill')
plt.ylabel('%', rotation=0)
plt.title('Churn rate by mean km per driving day');

"""# Le taux de désabonnement tend à augmenter à mesure que la distance moyenne parcourue par jour augmente, confirmant ce qui a été trouvé dans le cours précédent. Il serait utile d'examiner plus en détail les raisons pour lesquelles les utilisateurs parcourant de longues distances arrêtent d'utiliser l'application.

# #### **Taux de désabonnement par nombre de jours de conduite**
#
# Créez un autre histogramme similaire au précédent, mais cette fois-ci il doit représenter le taux de désabonnement pour chaque nombre de jours de conduite.

# Dans [33]:


# Histogram

"""

plt.figure(figsize=(12,5))
sns.histplot(data=df,
             x='driving_days',
             bins=range(1,32),
             hue='label',
             multiple='fill',
             discrete=True)
plt.ylabel('%', rotation=0)
plt.title('Churn rate per driving day');

"""# Le taux de désabonnement est le plus élevé pour les personnes qui n'ont pas beaucoup utilisé Waze au cours du dernier mois. Plus ils ont utilisé l'application, moins ils étaient susceptibles de se désabonner. Alors que 40 % des utilisateurs qui n'ont pas utilisé l'application du tout le mois dernier se sont désabonnés, personne n'a utilisé l'application pendant 30 jours ne s'est désabonné.

# Cela n'est pas surprenant. Si les personnes qui ont beaucoup utilisé l'application se désabonnaient, cela indiquerait probablement une insatisfaction. Lorsque les personnes qui n'ont pas utilisé l'application se désabonnent, cela peut être le résultat d'une insatisfaction passée, ou cela peut indiquer un besoin moindre pour une application de navigation. Peut-être qu'ils ont déménagé dans une ville avec de bons transports publics et n'ont plus besoin de conduire.

# #### **Proportion de sessions qui ont eu lieu le mois dernier**
#
# Créez une nouvelle colonne `percent_sessions_in_last_month` qui représente le pourcentage de sessions totales de chaque utilisateur qui ont eu lieu au cours de leur dernier mois d'utilisation.

# Dans [34]:

"""

df['percent_sessions_in_last_month'] = df['sessions'] / df['total_sessions']

"""# Quelle est la valeur médiane de la nouvelle colonne ?

# Dans [35]:

"""

df['percent_sessions_in_last_month'].median()

"""# Maintenant, créez un histogramme représentant la distribution des valeurs dans cette nouvelle colonne.

# Dans [36]:

# Histogramme

"""

histogrammer('percent_sessions_in_last_month',
             hue=df['label'],
             multiple='layer',
             median_text=False)

"""# Vérifiez la valeur médiane de la variable `n_days_after_onboarding`.

# Dans [37]:

"""

df['n_days_after_onboarding'].median()

"""# La moitié des personnes dans l'ensemble de données ont eu 40 % ou plus de leurs sessions au cours du dernier mois, pourtant le temps médian depuis l'inscription est presque de cinq ans.
#
# Crée un histogramme de `n_days_after_onboarding` uniquement pour les personnes qui ont eu 40 % ou plus de leurs sessions totales au cours du dernier mois.

# Dans [38]:

"""

data = df.loc[df['percent_sessions_in_last_month']>=0.4]
plt.figure(figsize=(5,3))
sns.histplot(x=data['n_days_after_onboarding'])
plt.title('Num. days after onboarding for users with >=40% sessions in last month');

"""# Le nombre de jours depuis l'inscription pour les utilisateurs ayant 40 % ou plus de leurs sessions totales survenues uniquement au cours du dernier mois suit une distribution uniforme. C'est très étrange. Il vaut la peine de demander à Waze pourquoi tant d'utilisateurs de longue date ont soudainement utilisé l'application autant au cours du dernier mois.

# ### **Tâche 3b. Gestion des valeurs aberrantes**
#
# Les diagrammes en boîte de la section précédente ont indiqué que beaucoup de ces variables ont des valeurs aberrantes. Ces valeurs aberrantes ne semblent pas être des erreurs de saisie de données ; elles sont présentes en raison des distributions asymétriques à droite.
#
# Selon ce que vous allez faire avec ces données, il peut être utile de remplir les données aberrantes avec des valeurs plus raisonnables. Une façon de procéder à cette imputation est de définir un seuil basé sur un percentile de la distribution.
#
# Pour pratiquer cette technique, écrivez une fonction qui calcule le 95e percentile d'une colonne donnée, puis remplace les valeurs supérieures au 95e percentile par la valeur au 95e percentile.
#
# Dans [39]:

"""

def outlier_imputer(column_name, percentile):
    # Calculate threshold
    threshold = df[column_name].quantile(percentile)
    # Impute threshold for values > than threshold
    df.loc[df[column_name] > threshold, column_name] = threshold

    print('{:>25} | percentile: {} | threshold: {}'.format(column_name, percentile, threshold))

"""# Ensuite, appliquez cette fonction aux colonnes suivantes :
# * `sessions`
# * `drives`
# * `total_sessions`
# * `driven_km_drives`
# * `duration_minutes_drives`

# Dans [40]:

"""

for column in ['sessions', 'drives', 'total_sessions',
               'driven_km_drives', 'duration_minutes_drives']:
               outlier_imputer(column, 0.95)

"""# Appelez `describe()` pour voir si votre modification a fonctionné.

# Dans [41]:

"""

df.describe()

"""# #### **Conclusion**
#
# L'analyse a révélé que le taux global de désabonnement est d'environ 17 %, et que ce taux est similaire entre les utilisateurs iPhone et Android.
#
# Peut-être que vous sentez qu'en explorant plus profondément les données, de plus en plus de questions se posent. Ce n'est pas inhabituel ! Dans ce cas, il vaut la peine de demander à l'équipe de données de Waze pourquoi tant d'utilisateurs ont utilisé l'application autant au cours du dernier mois.
#
# De plus, l'EDA a révélé que les utilisateurs qui conduisent sur de très longues distances pendant leurs jours de conduite ont _plus_ de chances de se désabonner, mais les utilisateurs qui conduisent plus fréquemment ont _moins_ de chances de se désabonner. La raison de cette incohérence est une opportunité pour des recherches supplémentaires, et ce serait un autre sujet à poser à l'équipe de données de Waze.
#
#
# <img src="images/Execute.png" width="100" height="100" align=left>
#
# ## **PACE: Exécuter**
#
# Réfléchissez aux questions dans votre document de stratégie PACE pour réfléchir à la phase d'exécution.

# ### **Tâche 4a. Résultats et évaluation**
#
# Après avoir créé des visualisations en Python, qu'avez-vous appris sur le jeu de données ? Quelles autres questions vos visualisations ont-elles soulevées que vous devriez explorer ?
#
# **Astuce pro :** Mettez-vous dans la perspective de votre client. Que voudraient-ils savoir ?
#
# Utilisez les champs de code suivants pour effectuer toute EDA supplémentaire en fonction des visualisations que vous avez déjà tracées. Utilisez également cet espace pour vous assurer que vos visualisations sont propres, faciles à comprendre et accessibles.
#
# **Demandez-vous :** Avez-vous pris en compte la couleur, le contraste, l'accentuation et l'étiquetage ?
#
#
# J'ai appris ....
#
# * Il manque des données dans le label de désabonnement des utilisateurs, il faudra donc peut-être effectuer un traitement des données avant de poursuivre l'analyse.
# * Il y a beaucoup d'observations aberrantes pour les trajets, il peut être pertinent de considérer une transformation de variable pour stabiliser la variation.
# * Le nombre de trajets et le nombre de sessions sont fortement corrélés, donc ces deux variables pourraient fournir des informations redondantes lorsque nous les incorporons dans un modèle.
# * En moyenne, les utilisateurs retenus ont moins de trajets que les utilisateurs désabonnés.
#
# Mes autres questions sont ....
#
# * Comment l'absence de données dans le label de désabonnement des utilisateurs se manifeste-t-elle ?
# * Qui sont les utilisateurs ayant un nombre de trajets extrêmement élevé ? Sont-ils des conducteurs de covoiturage ou des conducteurs commerciaux ?
# * Pourquoi les utilisateurs retenus ont-ils moins de trajets que les utilisateurs désabonnés ? Est-ce parce que les utilisateurs désabonnés ont une plus longue histoire d'utilisation de l'application Waze ?
# * Quelle est la démographie des utilisateurs retenus et des utilisateurs désabonnés ?
#
# Mon client voudrait probablement savoir ...
#
# * Quelles sont les principales variables associées au désabonnement des utilisateurs ?
# * Pouvons-nous mettre en place des politiques pour réduire le désabonnement des utilisateurs ?
#
#
#
# Utilisez les deux blocs de code suivants (ajoutez-en d'autres si vous le souhaitez) pour effectuer un EDA supplémentaire que vous jugez important en fonction du scénario donné.

# Dans [42]:

"""

df['monthly_drives_per_session_ratio'] = (df['drives']/df['sessions'])

"""# Dans [43]:"""

df.head(10)

"""# ### **Tâche 4b. Conclusion**
#
# Maintenant que vous avez exploré et visualisé vos données, l'étape suivante consiste à partager vos conclusions avec Harriet Hadzic, la Directrice de l'Analyse des Données chez Waze. Prenez en compte les questions suivantes lorsque vous préparez votre résumé exécutif. Réfléchissez aux points clés que vous souhaitez partager avec l'équipe, et quelles informations sont les plus pertinentes pour le projet de désabonnement des utilisateurs.
#
# **Questions :**
#
# 1. Quels types de distributions avez-vous remarqués dans les variables ? Qu'est-ce que cela vous a appris sur les données ?
#
# > *Presque toutes les variables étaient soit fortement asymétriques à droite, soit distribuées de manière uniforme. Pour les distributions asymétriques à droite, cela signifie que la plupart des utilisateurs avaient des valeurs dans la partie inférieure de l'éventail pour cette variable. Pour les distributions uniformes, cela signifie que les utilisateurs étaient généralement également susceptibles d'avoir des valeurs dans n'importe quelle partie de l'éventail pour cette variable.*
#
# 2. Y a-t-il quelque chose qui vous ait amené à penser que les données étaient erronées ou problématiques d'une manière quelconque ?
#
# > *La plupart des données n'étaient pas problématiques, et il n'y avait aucune indication qu'une variable quelconque était complètement erronée. Cependant, plusieurs variables avaient des valeurs aberrantes hautement improbables ou peut-être même impossibles, comme `driven_km_drives`. Certaines des variables mensuelles pourraient également poser problème, telles que `activity_days` et `driving_days`, car l'une a une valeur maximale de 31 tandis que l'autre a une valeur maximale de 30, ce qui indique que la collecte des données pourrait ne pas avoir eu lieu dans le même mois pour ces deux variables.*
#
# 3. Votre enquête a-t-elle donné lieu à d'autres questions que vous aimeriez explorer ou poser à l'équipe de Waze ?
#
# > *Oui. J'aimerais demander à l'équipe de données de Waze de confirmer que les variables mensuelles ont été collectées pendant le même mois, étant donné que certaines ont des valeurs maximales de 30 jours tandis que d'autres en ont 31. J'aimerais aussi savoir pourquoi tant d'utilisateurs de longue date ont soudainement commencé à utiliser l'application autant au cours du dernier mois. Y a-t-il eu quelque chose qui a changé dans le dernier mois qui aurait pu entraîner ce comportement ?*
#
# 4. Quel pourcentage d'utilisateurs s'est désabonné et quel pourcentage a été retenu ?
#
# > *Moins de 18 % des utilisateurs se sont désabonnés, et environ 82 % ont été retenus.*
#
# 5. Quels facteurs étaient corrélés au désabonnement des utilisateurs ? Comment ?
#
# > *La distance parcourue par jour de conduite était corrélée positivement avec le désabonnement des utilisateurs. Plus un utilisateur parcourait de kilomètres chaque jour de conduite, plus il était susceptible de se désabonner. D'autre part, le nombre de jours de conduite était corrélé négativement avec le désabonnement. Les utilisateurs qui ont conduit plus de jours au cours du dernier mois étaient moins susceptibles de se désabonner.*
#
# 6. Les utilisateurs plus récents étaient-ils plus représentés dans cet ensemble de données que les utilisateurs ayant une plus longue ancienneté ? Comment le savez-vous ?
#
# > *Non. Les utilisateurs de toutes les anciennetés, des tout nouveaux jusqu'à environ 10 ans, étaient relativement bien représentés dans les données. Cela est confirmé par l'histogramme de `n_days_after_onboarding`, qui révèle une distribution uniforme pour cette variable.*


"""